<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 16px; }
    .comparison-table {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      overflow-x: auto;
      background: white;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid #f3f4f6;
    }
    th {
      background: #f9fafb;
      font-weight: 600;
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      position: sticky;
      top: 0;
    }
    td {
      font-size: 14px;
    }
    .metric-label {
      font-weight: 600;
      color: #374151;
    }
    .fund-header {
      font-weight: 600;
      color: #111827;
      font-size: 14px;
    }
    .fund-code {
      font-size: 12px;
      color: #6b7280;
      font-family: monospace;
      display: block;
      margin-top: 2px;
    }
    .positive { color: #059669; font-weight: 600; }
    .negative { color: #dc2626; font-weight: 600; }
    .best { background: #d1fae5; }
  </style>
</head>
<body>
  <div class="comparison-table">
    <table id="comparisonTable">
      <thead>
        <tr id="headerRow"></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>

  <script>
    // Apps SDK compliant: read from structuredContent and _meta
    const structuredData = window.openai.toolOutput || {};
    const metadata = window.openai.toolResponseMetadata || {};
    
    // Use full data from metadata, fallback to structured data
    const funds = metadata.funds || structuredData.funds || [];
    
    // Initialize widget state
    let widgetState = window.openai.widgetState || { highlightedMetric: null, viewedAt: null };
    widgetState.comparedFunds = funds.map(f => f.proj_abbr_name || f.symbol);
    widgetState.viewedAt = new Date().toISOString();
    window.openai.setWidgetState(widgetState);

    // Build header
    const headerRow = document.getElementById('headerRow');
    const metricHeader = document.createElement('th');
    metricHeader.textContent = 'Metric';
    headerRow.appendChild(metricHeader);
    
    funds.forEach(fund => {
      const th = document.createElement('th');
      const fundName = fund.proj_name_en || fund.fund_name || 'N/A';
      const symbol = fund.proj_abbr_name || fund.symbol || 'N/A';
      th.innerHTML = `
        <div class="fund-header">${fundName}</div>
        <span class="fund-code">${symbol}</span>
      `;
      headerRow.appendChild(th);
    });

    // Metrics to compare (handle both field formats)
    const metrics = [
      { label: 'NAV', key: 'last_val,nav_value', format: (v) => v ? parseFloat(v).toFixed(4) : 'N/A', compare: false },
      { label: 'YTD Return', key: 'return_ytd,perf_ytd,performance.ytd', format: (v) => v !== null && v !== undefined ? parseFloat(v).toFixed(2) + '%' : 'N/A', compare: true },
      { label: '1Y Return', key: 'return_1y,perf_1y,performance.1y', format: (v) => v !== null && v !== undefined ? parseFloat(v).toFixed(2) + '%' : 'N/A', compare: true },
      { label: '3Y Return', key: 'return_3y,perf_3y,performance.3y', format: (v) => v !== null && v !== undefined ? parseFloat(v).toFixed(2) + '%' : 'N/A', compare: true },
      { label: '5Y Return', key: 'return_5y,perf_5y,performance.5y', format: (v) => v !== null && v !== undefined ? parseFloat(v).toFixed(2) + '%' : 'N/A', compare: true },
      { label: 'Risk Level', key: 'risk_spectrum,risk_level', format: (v) => v || 'N/A', compare: false },
      { label: 'AMC', key: 'unique_id,amc', format: (v) => v || 'N/A', compare: false },
    ];

    const getNestedValue = (obj, paths) => {
      const pathList = paths.split(',');
      for (const path of pathList) {
        const value = path.split('.').reduce((o, p) => o && o[p], obj);
        if (value !== null && value !== undefined) return value;
      }
      return null;
    };

    const tableBody = document.getElementById('tableBody');
    metrics.forEach(({ label, key, format, compare }) => {
      const row = document.createElement('tr');
      
      const labelCell = document.createElement('td');
      labelCell.className = 'metric-label';
      labelCell.textContent = label;
      row.appendChild(labelCell);

      const values = funds.map(fund => {
        const val = getNestedValue(fund, key);
        return val !== null && val !== undefined ? parseFloat(val) : null;
      });
      const maxValue = compare ? Math.max(...values.filter(v => v !== null && !isNaN(v))) : null;

      funds.forEach(fund => {
        const value = getNestedValue(fund, key);
        const numValue = value !== null && value !== undefined ? parseFloat(value) : null;
        const formatted = format(value);

        const cell = document.createElement('td');
        let className = '';
        if (compare && numValue !== null && !isNaN(numValue)) {
          className = numValue >= 0 ? 'positive' : 'negative';
          if (numValue === maxValue) className += ' best';
        }
        cell.className = className;
        cell.textContent = formatted;
        row.appendChild(cell);
      });

      tableBody.appendChild(row);
    });

    // Support for theme and display mode changes
    window.addEventListener('openai:set_globals', (event) => {
      const globals = event.detail.globals || {};
      if (globals.theme) {
        document.body.className = globals.theme;
      }
      if (globals.displayMode) {
        document.body.setAttribute('data-display-mode', globals.displayMode);
      }
    });
    
    // Initialize theme and display mode from current state
    if (window.openai?.theme) {
      document.body.className = window.openai.theme;
    }
    if (window.openai?.displayMode) {
      document.body.setAttribute('data-display-mode', window.openai.displayMode);
    }
  </script>
</body>
</html>

